##虚方法
 - 如果一个实例方法的申明中包含了关键字`virtual`，则称该方法为虚方法
 - 虚方法是已经实现了的，子类可以去覆盖也可以不用去覆盖重写，这个取决于需求
 - 注意： 
   - 虚函数只适用于继承关系的类对象，所以只有类的成员函数才能说明为虚函数
   - 静态成员函数不能是虚函数
   - 内联函数不能是虚函数
   - 构造函数不能是虚函数
   - 构析函数可以是虚函数
 - 不是虚函数，只有用new覆盖函数。
 - 虚方法与非虚方法重实例如下：


```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApplication3
{
    class class1
    {
        public void nonM1()
        {
            Console.WriteLine("这是class1的非虚方法");
        }

        public virtual void virM2()
        {
            Console.WriteLine("这是一个class1的虚方法");
        }

        public void M3()
        {
            nonM1();
            virM2();
            //Console.ReadKey();
        }

    }
    class class2:class1
    {
        public new void nonM1()
        {
            Console.WriteLine("这是class2的新构的非虚方法");
        }

        public override void virM2()
        {
            Console.WriteLine("这是class2的重写的虚方法");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            class1 c1 = new class1();
            class2 c2 = new class2();
            c1.M3();//打印的是：这是class1的非虚方法，这是一个class1的虚方法
            c2.M3();//打印的是：这是class1的非虚方法，这是class2的重写的虚方法
            Console.ReadKey();
            
        }
    }
}
```

- 如果不想让一个虚方法被重写，添加sealed关键字


```
class class2:class1
    {
        public  new void nonM1()
        {
            Console.WriteLine("这是class2的新构的非虚方法");
        }

        public sealed override void virM2()
        {
            Console.WriteLine("这是class2的重写的虚方法");
        }
    }
    class class3:class2
    {
        //加了sealed关键字密封，无法进行重写
        public override void virM2()
        {

        }
    }
```





